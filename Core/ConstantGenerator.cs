using System.IO;
using System.Text;
using UnityEngine;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEditorInternal;

namespace ConstGen
{
    public class ConstantGenerator
    {
        private const string HeaderTextFormat =
@"// ========================================================================
// [ Auto Generated File ]
// Generated By: {0}
// (Generated date: {1})

// Changes for this script by hand might be lost when auto-generation is run.

// NOTE: DO NOT DELETE THIS FILE, especially if there are scripts that already
// referencing it as the auto generation (the logic that Generates this file if it doesn't exist)
// will fail to execute since the scripts referencing it will throw an error 
// ========================================================================
";
        public const string OutputFileNamespace = "namespace ConstGenConstants";
        public const string FilePathFormat = "{0}/{1}.cs";
        public const string TemplatePathFormat = "{0}/{1}.txt";
        public const string ClassFormat = "public static class {0}";
        public ConstGenSettings settings;
        // public const string StringPrefix = "_";

        public string GetHeaderText( string generatorName )
        {
            return string.Format(
                HeaderTextFormat, generatorName, DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss")
            );
        }

        public string GetOutputPath()
        {
            // string s = "/Editor/Core/ConstantGenerator.cs";
            // string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            // string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            // folderPath = folderPath.Replace( s, String.Empty );
            // folderPath += "/Generated Constants";
            // return folderPath;

            return "Assets/Scripts/ConstGen Files/Generated Constants";
        }

        public string GetTemplateOutputPath()
        {
            // string s = "/Core/ConstantGenerator.cs";
            // string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            // string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            // folderPath = folderPath.Replace( s, String.Empty );
            // folderPath += "/Generated Generators";
            // return folderPath;

            return "Assets/Scripts/ConstGen Files/Custom Generators/Editor";
        }

#if UNITY_EDITOR
        public static ConstGenSettings GetSettingsFile()
        {
            string s = "/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Settings/ConstGenSettings.asset";

            return AssetDatabase.LoadAssetAtPath<ConstGenSettings>( folderPath );
        }

        public string GetTemplatesPath()
        {
            string s = "/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Templates";
            return folderPath;
        }

        public static Texture GetLogo()
        {
            string s = "/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Images/INF.png";
            Texture t = AssetDatabase.LoadAssetAtPath<Texture>( folderPath );
            return t;
        }

        public static Texture GetBorder()
        {
            string s = "/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Images/Border.png";
            Texture t = AssetDatabase.LoadAssetAtPath<Texture>( folderPath );
            return t;
        }

        public static void ForceGenerateALL()
        {
            Directory.Delete( "Assets/Scripts/ConstGen Files/Generated Constants", true );
            AssetDatabase.DeleteAsset( "Assets/Scripts/ConstGen Files/Generated Constants.meta" );
            AssetDatabase.Refresh();
        }
#endif

        /// <summary>
        /// Generates the code file into target path
        /// </summary>
        /// <param name="filePath">path of the file (if no file is present, one will be created instead)</param>
        /// <param name="directoryPath">directory path to the file</param>
        /// <param name="contentCallback">method callback that returns the stringbuilder content written to the generated file</param>
        public void GenerateCodeFile(string filePath, string directoryPath ,System.Action<StringBuilder> contentCallback)
        {
            Debug.Assert(contentCallback != null);

            // Create Directory if none is present
            if ( !Directory.Exists( directoryPath )) 
            {
                Debug.LogWarningFormat( "[{0}] Directory Doesn't Exist, Creating one...",
                    directoryPath );
                Directory.CreateDirectory(directoryPath);
            }
            try 
            {
                // Always create a new file because overwriting to existing file may generate mal-formatted script.
                // for instance, when the number of tags is reduced, last tag will be remain after the last curly brace in the file.
                using (FileStream stream = File.Open(filePath, FileMode.Create, FileAccess.Write))
                {
                    using (StreamWriter writer = new StreamWriter(stream))
                    {
                        StringBuilder codeContent = new StringBuilder();

                        // call callback that returns the code content in a stringbuilder
                        contentCallback(codeContent);

                        // write content to file
                        writer.Write(codeContent.ToString());
                    }
                }

                // using (StreamReader streamReader = new StreamReader(path))
                // {
                //     Debug.Log( streamReader.ReadToEnd() );
                // }
            }
            catch (System.Exception e)
            {
                Debug.LogException(e);
            }

#if UNITY_EDITOR
            AssetDatabase.Refresh();
#endif
        }

        private string UnderscoreIdentifier( string str )
        {
            string result = Regex.Replace(str, "([^a-zA-Z0-9])", "_");

            if ('0' <= result[0] && result[0] <= '9')
            {
                result = result.Insert(0, "_");
            }

            return result;            
        }

        public string EscapeDoubleQuote(string str)
        {
            return str.Replace("\"", "\"\"");
        }

        public string CreateIdentifier(string str )
        {
            if ( settings == null )
                settings = GetSettingsFile();

            string formattedIndentifier = string.Empty;

            if ( settings.indentifierFormat == ConstGenSettings.IndentifierFormat.Under_Score_Divider )
            {
                formattedIndentifier = UnderscoreIdentifier( str );
            } 
            else 
            {
                formattedIndentifier = PascalCaseNoSpaceIndentifier( str );
            }

            return formattedIndentifier;
        }

        public string PascalCaseNoSpaceIndentifier( string str )
        {
            // turn all the unnecessary characters invalid for naming conventions to an underscore
            string validNaming = UnderscoreIdentifier( str );

            // divide the string into individual words
            char[] dividers = { '_' };
            string[] words = validNaming.Split( dividers ); 

            // loop through it and turn it's first letter into upper case
            for (int i = 0; i < words.Length; i++)
            {
                if ( words[i] == string.Empty )
                    continue;

                string s = words[i];

                // turn the first letter to upper case then add the rest of the word to it
                words[i] = char.ToUpper(s[0]) + s.Substring(1, s.Length-1);
            }

            string formatedString = string.Empty;

            // append all words into a single string
            for (int i = 0; i < words.Length; i++) 
            {
                formatedString += words[i];
            }

            return formatedString;
        }

        // public string RemoveChars( string str, char[] toRemoveChars )
        // {
        //     string formated = str;

        //     for (int i = 0; i < toRemoveChars.Length; i++)
        //     {
        //         // for each char we will remove it from the string

        //         // check if the char present on the string
        //         while ( formated.IndexOf( toRemoveChars[i] ) >= 0 )
        //         {
        //             // cache it's index
        //             int index = formated.IndexOf(toRemoveChars[i]);

        //             // remove it and store it back to the string
        //             formated = formated.Remove(index,1);
        //         }                
        //     }

        //     return formated;
        // }

        // public string NoSpaceIndentifier( string str )
        // {
        //     string formattedString = UnderscoreIdentifier( str );
        //     formattedString = RemoveChars( formattedString,new char[] { '_', '-' } );
        //     return formattedString;
        // }
    }   
}
