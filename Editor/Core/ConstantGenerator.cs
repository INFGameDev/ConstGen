using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;
using UnityEditorInternal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace ConstGen
{
    public class ConstantGenerator
    {
        private const string HeaderTextFormat =
@"// ========================================================================
// [ Auto Generated File ]
// Generated By: {0}
// (Generated date: {1})

// Changes for this script by hand might be lost when auto-generation is run.

// NOTE: DO NOT DELETE THIS FILE, especially if there are scripts that already
// referencing it as the auto generation (the logic that Generates this file if it doesn't exist)
// will fail to execute since the scripts referencing it will throw an error 
// ========================================================================
";
        public const string OutputFileNamespace = "namespace ConstGenConstants";
        public const string FilePathFormat = "{0}/{1}.cs";
        public const string TemplatePathFormat = "{0}/{1}.txt";
        public const string ClassFormat = "public static class {0}";
        // public const string StringPrefix = "_";

        public string GetHeaderText( string generatorName )
        {
            return string.Format(
                HeaderTextFormat, generatorName, DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss")
            );
        }

        public string GetOutputPath()
        {
            string s = "/Editor/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Generated Constants";
            return folderPath;
        }

        public static ConstGenSettings GetSettingsFile()
        {
            string s = "/Editor/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Others/ConstGenSettings.asset";

            return AssetDatabase.LoadAssetAtPath<ConstGenSettings>( folderPath );
        }

        public string GetTemplateOutputPath()
        {
            string s = "/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Generated Generators";
            return folderPath;
        }

        public string GetTemplatesPath()
        {
            string s = "/Editor/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Templates";
            return folderPath;
        }

        public static Texture GetLogo()
        {
            string s = "/Editor/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Others/INF.png";
            Texture t = AssetDatabase.LoadAssetAtPath<Texture>( folderPath );
            return t;
        }

        public static Texture GetBorder()
        {
            string s = "/Editor/Core/ConstantGenerator.cs";
            string[] guidPath = AssetDatabase.FindAssets( "t:script ConstantGenerator" );
            string folderPath = AssetDatabase.GUIDToAssetPath(guidPath[0]);
            folderPath = folderPath.Replace( s, String.Empty );
            folderPath += "/Others/Border.png";
            Texture t = AssetDatabase.LoadAssetAtPath<Texture>( folderPath );
            return t;
        }

        /// <summary>
        /// Generates the code file into target path
        /// </summary>
        /// <param name="filePath">path of the file (if no file is present, one will be created instead)</param>
        /// <param name="directoryPath">directory path to the file</param>
        /// <param name="contentCallback">method callback that returns the stringbuilder content written to the generated file</param>
        public void GenerateCodeFile(string filePath, string directoryPath ,System.Action<StringBuilder> contentCallback)
        {
            Debug.Assert(contentCallback != null);

            // Create Directory if none is present
            if ( !Directory.Exists( directoryPath )) 
            {
                Debug.LogWarningFormat( "[{0}] Directory Doesn't Exist, Creating one...",
                    directoryPath );
                Directory.CreateDirectory(directoryPath);
            }
            try 
            {
                // Always create a new file because overwriting to existing file may generate mal-formatted script.
                // for instance, when the number of tags is reduced, last tag will be remain after the last curly brace in the file.
                using (FileStream stream = File.Open(filePath, FileMode.Create, FileAccess.Write))
                {
                    using (StreamWriter writer = new StreamWriter(stream))
                    {
                        StringBuilder codeContent = new StringBuilder();

                        // call callback that returns the code content in a stringbuilder
                        contentCallback(codeContent);

                        // write content to file
                        writer.Write(codeContent.ToString());
                    }
                }

                // using (StreamReader streamReader = new StreamReader(path))
                // {
                //     Debug.Log( streamReader.ReadToEnd() );
                // }
            }
            catch (System.Exception e)
            {
                Debug.LogException(e);
            }
            AssetDatabase.Refresh();
        }

        /// <summary>
        /// Check if there are changes present in the two list of property strings
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public bool UpdateChangeCheck(List<string> a, List<string> b)
        {
            if (a.Count != b.Count) {
                return true;
            }
            else
            {
                // loop thru all new tags and compare them to the old ones
                for (int i = 0; i < a.Count; i++)
                {
                    if (!string.Equals(a[i], b[i]))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public string MakeIdentifier(string str)
        {
            string result = Regex.Replace(str, "([^a-zA-Z0-9])", "_");
            if ('0' <= result[0] && result[0] <= '9')
            {
                result = result.Insert(0, "_");
            }

            return result;
        }

        public string EscapeDoubleQuote(string str)
        {
            return str.Replace("\"", "\"\"");
        }
    }   
}
